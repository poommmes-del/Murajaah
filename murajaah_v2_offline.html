<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Murajaah — Révision du Coran</title>
  
  <!-- Ajouts PWA -->
  <meta name="theme-color" content="#0c0f14" />
  <link rel="manifest" href="manifest.json" />
  <!-- Fin des ajouts PWA -->

  <style>
    :root{--bg:#0c0f14;--fg:#e6e9ef;--muted:#a6adbb;--pri:#5b8cff;--pri-2:#9d7cff;--acc:#1dd1a1;--danger:#ff6b6b;--glass:rgba(255,255,255,0.06)}
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 20% -10%, #1a2340 0%, transparent 60%),radial-gradient(1000px 700px at 120% 10%, #2a144a 0%, transparent 60%),linear-gradient(#0b0f16,#0b0f16);color:var(--fg);font:16px/1.5 Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    header{padding:16px 16px 0;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .brand{display:flex;align-items:center;gap:12px;cursor:pointer}
    .logo{width:44px;height:44px;border-radius:12px;background:linear-gradient(135deg,var(--pri),var(--pri-2));display:grid;place-items:center;box-shadow:0 6px 30px rgba(91,140,255,.35), inset 0 0 12px rgba(255,255,255,.2)}
    .logo svg{width:28px;height:28px;filter:drop-shadow(0 2px 6px rgba(0,0,0,.35))}
    h1{margin:0;font-size:20px;font-weight:800;letter-spacing:.2px}

    main#main{max-width:1180px;margin:0 auto;padding:8px 16px 40px}
    .panel{background:var(--glass);backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.08);border-radius:14px;padding:14px}

    .grid{display:grid;gap:12px}
    .grid.selection{grid-template-columns:1fr}
    .grid.collapsed{grid-template-columns:1fr}

    .controls{display:grid;gap:10px}
    .field{display:grid;gap:6px}
    label{font-size:13px;color:var(--muted)}
    select,button,input[type="text"],input[type="checkbox"],input[type="number"]{padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.10);background:linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));color:var(--fg);outline:none}
    button{cursor:pointer;transition:transform .05s ease, box-shadow .2s ease}
    button.primary{background:linear-gradient(135deg,var(--pri),var(--pri-2));border:none;box-shadow:0 10px 26px rgba(91,140,255,.25);color:#fff}
    button.primary:active{transform:translateY(1px)}
    .row{display:flex;gap:8px;flex-wrap:wrap}

    .ayah{min-height:430px;display:grid;grid-template-rows:auto auto 1fr auto;gap:12px;padding:20px;cursor:pointer;max-width:1100px;margin:0 auto}
    .meta{display:flex;flex-wrap:wrap;gap:8px;color:var(--muted);font-size:13px}
    .arabic{font-family:"Amiri","Scheherazade New","Noto Naskh Arabic",serif;font-size:32px;line-height:1.9;direction:rtl}
    .trans{font-size:16px;color:#d7deee}
    .actions{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .pill{padding:6px 10px;border-radius:50px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);font-size:12px;color:#c7cee0; display: flex; align-items: center; gap: 4px; /* Ajout pour l'icône */}
    .muted{color:var(--muted)} .hidden{display:none}
    .footer{margin-top:14px;color:var(--muted);font-size:12px;text-align:center}
    .mode{display:flex;gap:14px;align-items:center}
    .mode input{accent-color:var(--pri)}
    .spinner{width:16px;height:16px;border:2px solid rgba(255,255,255,.25);border-top-color:#fff;border-radius:50%;display:inline-block;animation:spin 0.8s linear infinite;vertical-align:middle}
    @keyframes spin{to{transform:rotate(360deg)}}

    .checkgrid{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:8px;max-height:260px;overflow:auto;padding:6px;border-radius:10px;border:1px dashed rgba(255,255,255,0.12)}
    .chk{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);padding:8px;border-radius:10px}
    .chk input{width:18px;height:18px;accent-color:var(--acc)}

    .topbar{display:flex;gap:8px;align-items:center;padding:8px 0}
    .ghost{background:transparent;border:1px dashed rgba(255,255,255,0.25);color:var(--fg)}

    .chunk{display:grid;gap:14px}
    .chunk-item{padding:10px 12px;border-radius:10px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.08)}
    .chunk-item .num{font-size:12px;color:var(--muted)}

    /* Kill any stray control after Pool (but allow primary too) */
    .actions > :not(.row):not(audio):not(.pill):not(.primary){display:none !important}

    /* Styles pour la modale */
    .modal-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(4px);
      display: flex; justify-content: center; align-items: center;
      z-index: 1000; transition: opacity 0.3s ease;
    }
    .modal-content {
      background: var(--bg); padding: 20px; border-radius: 16px;
      width: 90%; max-width: 500px; max-height: 90vh; overflow-y: auto;
      border: 1px solid rgba(255,255,255,0.15);
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    .modal-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 16px;
    }
    .modal-header h2 {
      margin: 0; font-size: 1.4em;
    }
    .close-btn {
      background: none; border: none; color: var(--muted); font-size: 1.5em;
      cursor: pointer; transition: color 0.1s;
    }
    .close-btn:hover { color: var(--fg); }
    .modal-controls {
        display: grid; gap: 10px;
        margin-top: 15px;
    }
    .modal-controls .row {
        align-items: center;
    }
    .preload-progress {
        background-color: var(--glass);
        height: 10px;
        border-radius: 5px;
        overflow: hidden;
        margin-top: 8px;
    }
    .preload-bar {
        height: 100%;
        width: 0%;
        background-color: var(--acc);
        transition: width 0.1s linear;
    }
    .info-cache {
        font-size: 13px;
        color: var(--muted);
        padding: 8px 0;
        border-top: 1px solid rgba(255,255,255,0.08);
        margin-top: 15px;
    }
    .info-cache .danger {
        color: var(--danger);
        font-weight: bold;
    }
    
  </style>
</head>
<body>
  <header>
    <div class="brand" id="brand-home" title="Accueil">
      <div class="logo" aria-hidden="true">
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <defs>
            <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0%" stop-color="#fff" stop-opacity=".95"/>
              <stop offset="100%" stop-color="#ffe08a" stop-opacity=".95"/>
            </linearGradient>
          </defs>
          <path d="M50 10c-9 2-16 8-20 16-2 4-3 8-3 12 0 3 1 6 3 8 2 2 5 3 8 2 4-1 7-4 8-8 1-3 0-6-2-8-3-2-7-1-10 1 4-9 10-15 18-19l-2-4Z" fill="url(#g)"/>
          <circle cx="22" cy="18" r="3" fill="#fff" opacity=".9"/>
        </svg>
      </div>
      <div>
        <h1>Murajaah</h1>
      </div>
    </div>
    <div class="topbar">
      <button id="btn-back" class="pill ghost hidden" title="Revenir à la sélection">⟵ Revenir à la sélection</button>
      
      <!-- NOUVEAU BOUTON DE GESTION DU CACHE (TOUJOURS VISIBLE) -->
      <button id="btn-cache-manager" class="pill" title="Gérer le mode hors-ligne" aria-label="Gérer le mode hors-ligne">
        <!-- Icône d'engrenage (Settings) en SVG -->
        <svg fill="currentColor" viewBox="0 0 20 20" width="16" height="16" aria-hidden="true">
            <path fill-rule="evenodd" d="M11.493 2.94a.75.75 0 010 1.115l-1.464 2.196a.5.5 0 00-.07.243v3.702a1 1 0 01-1 1h-.5a1 1 0 01-1-1V6.5a.5.5 0 00-.07-.243L5.507 4.055a.75.75 0 010-1.115 6 6 0 115.986 0zM10 18a8 8 0 100-16 8 8 0 000 16z" clip-rule="evenodd"></path>
        </svg>
        Cache
      </button>
      
      <div class="pill">v2.0-offline</div>
    </div>
  </header>

  <main id="main" class="grid selection">
    <section class="panel controls" id="controls" aria-label="Sélection">
      <div class="field">
        <label>Mode de sélection</label>
        <div class="mode">
          <label><input type="radio" name="mode" id="mode-juz" value="juz"> Par Juz</label>
          <label><input type="radio" name="mode" id="mode-surah" value="surah" checked> Par Sourate</label>
        </div>
      </div>

      <div class="field" id="field-juz">
        <label>Juz (cases à cocher)</label>
        <div class="row">
          <button id="juz-all" type="button">Tout</button>
        </div>
        <div id="juzChecks" class="checkgrid"></div>
      </div>

      <div class="field" id="field-surah">
        <label>Sourates (cases à cocher)</label>
        <div class="row">
          <input id="surahSearch" type="text" placeholder="Rechercher (ex: Baqarah, الفاتحة, 1)…" style="flex:1"/>
          <button id="surah-all" type="button">Tout</button>
        </div>
        <div id="surahChecks" class="checkgrid"></div>
      </div>

      <div class="field">
        <label for="reciter">Récitateur</label>
        <select id="reciter">
          <option value="ar.alafasy" selected>Mishary Alafasy</option>
          <option value="ar.husary">Mahmoud Al‑Husary</option>
          <option value="ar.shaatree">Abu Bakr Ash‑Shaatree</option>
          <option value="ar.hudhaify">Ali Al‑Hudhaify</option>
          <option value="ar.minshawi">Muhammad Al‑Minshawi</option>
        </select>
      </div>
      <div class="field">
        <label for="translation">Traduction</label>
        <select id="translation">
          <option value="none">Aucune (arabe seul)</option>
          <option value="fr.hamidullah" selected>Français — Hamidullah</option>
          <option value="en.asad">English — Asad</option>
          <option value="en.pickthall">English — Pickthall</option>
        </select>
      </div>

      <div class="row">
        <button class="primary" id="btn-random" style="flex: 1;">Tirer un verset</button>
        <!-- L'ancien bouton de gestion du cache a été retiré d'ici -->
      </div>
      
      <div class="row">
        <button id="btn-diagnose">Diagnostiquer API</button>
        <div class="muted" id="status">Prêt.</div>
      </div>
    </section>

    <section class="panel ayah hidden" id="card" aria-live="polite">
      <div class="meta" id="meta">—</div>
      <div class="arabic" id="ar">—</div>
      <div class="trans" id="tr" dir="auto"></div>
      <div class="chunk" id="chunk"></div>
      <div class="actions">
        <div class="row">
          <button id="btn-reroll" class="primary">Tirer un verset</button>
          <button id="btn-next" class="ghost">Suivant ▶︎</button>
        </div>
        <audio id="audio" controls class="hidden"></audio>
        <span class="pill" id="poolInfo">Pool : 0 versets</span>
      </div>
    </section>
  </main>

  <div class="footer">Raccourcis: Espace = Audio · →/clic = Suivant </div>

  <!-- MODALE DE GESTION DU CACHE (cachée par défaut) -->
  <div id="modal-cache" class="modal-overlay hidden" aria-modal="true" role="dialog" aria-labelledby="modal-title">
      <div class="modal-content">
          <div class="modal-header">
              <h2 id="modal-title">Configuration du Mode Hors-Ligne</h2>
              <button class="close-btn" id="close-cache-modal">&times;</button>
          </div>

          <p class="muted">Choisissez le récitateur, la traduction, et les sourates spécifiques que vous souhaitez rendre disponibles hors-ligne. Cela peut prendre beaucoup d'espace.</p>
          
          <section class="modal-controls">
              <!-- Sélection du Récitateur -->
              <div class="field">
                <label>Récitateur(s) à mettre en cache (Audio)</label>
                <div id="cacheReciters" class="checkgrid" style="max-height: 150px;">
                    <!-- Les options seront générées ici par JS -->
                </div>
              </div>

              <!-- Sélection de la Traduction -->
              <div class="field">
                <label>Traduction(s) à mettre en cache (Texte)</label>
                <div id="cacheTranslations" class="checkgrid" style="grid-template-columns: repeat(auto-fill,minmax(120px,1fr)); max-height: 120px;">
                    <!-- Les options seront générées ici par JS -->
                </div>
              </div>

              <!-- Sélection de la Plage de Sourates -->
              <div class="field">
                <label>Plage de Sourates</label>
                <div class="row">
                    <label style="flex: 1; text-align: right;">De (1 à 114) :
                        <input type="number" id="cacheSurahStart" value="1" min="1" max="114" style="text-align: center;"/>
                    </label>
                    <label style="flex: 1; text-align: right;">À (1 à 114) :
                        <input type="number" id="cacheSurahEnd" value="114" min="1" max="114" style="text-align: center;"/>
                    </label>
                </div>
              </div>
              
              <button id="btn-start-preload" class="primary">Lancer le téléchargement (Toutes les Sourates)</button>
              
              <div id="preload-progress-container" class="hidden">
                  <p id="preload-status-text" class="muted" style="text-align: center;"></p>
                  <div class="preload-progress">
                      <div class="preload-bar" id="preload-bar" style="width: 0%;"></div>
                  </div>
              </div>

              <div class="info-cache">
                <p>⚠️ <span class="danger">Attention :</span> Le mode hors-ligne prend de l'espace sur votre téléphone. Pour le libérer, vous devez vider le cache de l'application *Murajaah* dans les paramètres de votre navigateur.</p>
              </div>
          </section>
      </div>
  </div>


<script>
const byId=(id)=>document.getElementById(id);
const pretty=(n)=>n.toString().padStart(3,'0');
const uniq=(arr)=>[...new Set(arr)];

const FLASHCARD=true;
const SMART=true;
const CHUNK_SIZE=4;
const DEFAULT_RECENCY=30;
let suppressCardClickUntil=0;

// Utilisation de la liste des proxies pour la résilience.
const PROXIES=[(url)=>`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,(url)=>`https://cors.isomorphic-git.org/${url}`,(url)=>`https://thingproxy.freeboard.io/fetch/${url}`];
async function fetchJSONWithFallback(url, opts={}){ try{ const r=await fetch(url,opts); if(r.ok) return r.json(); throw new Error(`HTTP ${r.status}`);}catch(e){ for(const wrap of PROXIES){ try{ const r=await fetch(wrap(url),opts); if(r.ok) return r.json(); }catch(_){} } throw e; } }

const API={ 
  sutanlab:{ 
    surahList:'https://api.quran.sutanlab.id/surah', 
    juz:(n)=>`https://api.quran.sutanlab.id/juz/${n}`, 
    surahAyah:(s,a)=>`https://api.quran.sutanlab.id/surah/${s}/${a}` 
  }, 
  alquran:{ 
    surahList:'https://api.alquran.cloud/v1/surah', 
    juz:(n)=>`https://api.alquran.cloud/v1/juz/${n}/quran-uthmani`, 
    ayahTr:(s,a,ed)=>`https://api.alquran.cloud/v1/ayah/${s}:${a}/${ed}`, 
  }, 
  githubRaw:{ 
    surah:(s)=>`https://raw.githubusercontent.com/semarketir/quranjson/master/source/surah/surah_${s}.json` 
  } 
};

const Cache={ surahs:null, juzMap:new Map(), ayahText:new Map(), surahIndex:[] };

// Définitions des Récitateurs et Traductions pour la gestion du cache
const RECITER_OPTIONS = [
    { value: 'ar.alafasy', label: 'Mishary Alafasy' },
    { value: 'ar.husary', label: 'Mahmoud Al‑Husary' },
    { value: 'ar.shaatree', label: 'Abu Bakr Ash‑Shaatree' },
    { value: 'ar.hudhaify', label: 'Ali Al‑Hudhaify' },
    { value: 'ar.minshawi', label: 'Muhammad Al‑Minshawi' },
];

const TRANSLATION_OPTIONS = [
    { value: 'fr.hamidullah', label: 'Français (Hamidullah)' },
    { value: 'en.asad', label: 'Anglais (Asad)' },
    { value: 'en.pickthall', label: 'Anglais (Pickthall)' },
    // Option 'none' n'est pas nécessaire ici car le texte arabe est toujours inclus
];


// Classe SmartShuffle
class SmartShuffle{ constructor(items=[],historySize=DEFAULT_RECENCY){ this.hist=[]; this.ptr=-1; this.historySize=historySize; this.all=[]; this.bag=[]; this.set(items); } set(items){ this.all=uniq(items); this._refill(); } setHistorySize(n){ this.historySize=Math.max(0,n|0); } _fy(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } } _refill(){ this.bag=this.all.slice(); this._fy(this.bag); const last=(this.hist && this.hist.length)? this.hist[this.hist.length-1] : undefined; if(this.bag.length>1 && last!==undefined && this.bag[0]===last){ const j=Math.floor(Math.random()*(this.bag.length-1))+1; [this.bag[0],this.bag[j]]=[this.bag[j],this.bag[0]]; } } next(smart=true){ if(this.ptr>=0 && this.ptr<this.hist.length-1){ this.hist=this.hist.slice(0,this.ptr+1);} if(!this.bag.length) this._refill(); let idx=0; if(smart && this.historySize>0){ const recent=new Set(this.hist.slice(-this.historySize)); idx=this.bag.findIndex(x=>!recent.has(x)); if(idx===-1) idx=0; } else { idx=Math.floor(Math.random()*this.bag.length);} const picked=this.bag.splice(idx,1)[0]; this.hist.push(picked); this.ptr=this.hist.length-1; return picked; } prev(){ if(this.ptr>0){ this.ptr--; return this.hist[this.ptr]; } return null; } forward(){ if(this.ptr>=0 && this.ptr<this.hist.length-1){ this.ptr++; return this.hist[this.ptr]; } return null; } }

function ayahKey(s,a){ return `${s}:${a}` }

async function loadSurahList(){ 
  if(Cache.surahs) return Cache.surahs; 
  try{ 
    const j=await fetchJSONWithFallback(API.sutanlab.surahList); 
    if(j && j.data){ 
      Cache.surahs=j.data.map(x=>({number:x.number, nameAr:x.name.short||x.name, nameEn:x.name.transliteration?.en||x.englishName, numberOfAyahs:x.numberOfVerses||x.numberOfAyahs, numberOfAyahsActual: x.numberOfVerses||x.numberOfAyahs})); 
      return Cache.surahs; 
    } 
  }catch(_){ } 
  // Fallback API
  try{ 
    const a=await fetchJSONWithFallback(API.alquran.surahList); 
    Cache.surahs=a.data.map(x=>({number:x.number, nameAr:x.name, nameEn:x.englishName, numberOfAyahs:x.numberOfAyahs, numberOfAyahsActual: x.numberOfAyahs})); 
    return Cache.surahs; 
  }catch(_){ } 
  // Fallback si tout échoue (devrait être suffisant pour charger l'App Shell)
  Cache.surahs=[...Array(114)].map((_,i)=>({number:i+1,nameAr:`سورة ${i+1}`,nameEn:`Surah ${i+1}`,numberOfAyahs:200,numberOfAyahsActual:200})); 
  return Cache.surahs; 
}

async function buildSurahChecks(){ 
  const list = await loadSurahList(); 
  Cache.surahIndex = list.map(s=>({ 
    value: String(s.number), 
    label: `${pretty(s.number)} · ${s.nameEn||''} — ${s.nameAr||''}`.trim(), 
    n: s.number, 
    // Utilise la meilleure estimation du nombre de versets.
    count: s.numberOfAyahsActual||s.numberOfAyahs||200 
  })); 
  const box = byId('surahChecks'); 
  box.innerHTML=''; 
  const frag=document.createDocumentFragment(); 
  for(const it of Cache.surahIndex){ 
    const lab=document.createElement('label'); lab.className='chk'; 
    lab.dataset.label=it.label.toLowerCase(); 
    const cb=document.createElement('input'); cb.type='checkbox'; cb.value=it.value; cb.name='surah'; 
    const span=document.createElement('span'); span.textContent=it.label; 
    lab.appendChild(cb); lab.appendChild(span); frag.appendChild(lab); 
  } 
  box.appendChild(frag); 
  const first=box.querySelector('input[type="checkbox"]'); 
  if(first){ first.checked=true; } 
}

function filterSurahChecks(query){ 
  const q=(query||'').toLowerCase().trim(); 
  const items = byId('surahChecks').querySelectorAll('.chk'); 
  items.forEach(l=>{ 
    const match = !q || (l.dataset.label||'').includes(q); 
    l.style.display = match? 'flex':'none'; 
  }); 
}
function setAllChecks(containerId, checked){ 
  const box = byId(containerId); 
  box.querySelectorAll('input[type="checkbox"]').forEach(cb=>cb.checked=!!checked); 
  box.dispatchEvent(new Event('change')); 
}
function selectedFromChecks(containerId){ 
  return Array.from(byId(containerId).querySelectorAll('input[type="checkbox"]:checked')).map(cb=>cb.value); 
}

async function loadJuz(j){ 
  const key = String(j); 
  if(Cache.juzMap.has(key)) return Cache.juzMap.get(key); 
  try{ 
    const d=await fetchJSONWithFallback(API.sutanlab.juz(j)); 
    if(d && d.data){ 
      const verses=d.data.verses||d.data.ayahs||[]; 
      const list=verses.map(v=>({ s:v.surah?.number||v.number?.surah||v.surahNumber||v.surah?.number||v.surah?.id, a:v.number?.inSurah||v.numberInSurah||v.verseNumber })).filter(x=>+x.s&&+x.a); 
      Cache.juzMap.set(key,list); 
      return list; 
    } 
  }catch(_){ } 
  // Fallback Alquran.cloud pour Juz
  try{
    const a=await fetchJSONWithFallback(API.alquran.juz(j)); 
    const list=(a.data.ayahs||[]).map(v=>({ s:v.surah.number, a:v.numberInSurah })); 
    Cache.juzMap.set(key,list); 
    return list; 
  }catch(_){ }
  return [];
}

/**
 * Récupère le texte, la traduction et l'audio d'un verset.
 * @param {number} s Numéro de sourate
 * @param {number} a Numéro de verset
 * @param {string} trEd Édition de traduction
 * @param {string} reciterEd Édition du récitateur
 */
async function getAyah(s,a,trEd,reciterEd){ 
  let arabic="", tr="", audio=""; 
  
  // Utilisation de l'API Alquran.cloud pour récupérer Arabe, Audio et Traduction en 1 ou 2 requêtes
  const audioEdition = reciterEd;
  const arabicEdition = 'quran-uthmani'; // Texte Othmani
  const editions = [arabicEdition, audioEdition];
  if (trEd && trEd !== 'none') {
      editions.push(trEd);
  }
  
  try{ 
    // Tente de récupérer tout en une seule requête
    const r = await fetchJSONWithFallback(`https://api.alquran.cloud/v1/ayah/${s}:${a}/${editions.join(',')}`);
    if(r && r.data){
      // Les données sont dans un tableau ordonné par les éditions demandées
      const parts = r.data.ayahs;

      const arabicPart = parts.find(p => p.edition?.identifier === arabicEdition);
      const audioPart = parts.find(p => p.edition?.identifier === audioEdition);
      const trPart = parts.find(p => p.edition?.identifier === trEd);

      arabic = arabicPart?.text || ""; 
      audio = audioPart?.audio || ""; 
      tr = trPart?.text || "";
    }
  }catch(_){
      // Fallback si la requête multiple échoue
      try {
          const r = await fetchJSONWithFallback(`https://api.alquran.cloud/v1/ayah/${s}:${a}/${arabicEdition},${reciterEd}`);
          if(r && r.data){
              arabic = r.data.ayahs[0]?.text || ""; 
              audio = r.data.ayahs[1]?.audio || ""; 
          }
          if (trEd && trEd !== 'none') {
              const t = await fetchJSONWithFallback(API.alquran.ayahTr(s,a,trEd)); 
              tr = t?.data?.text||""; 
          }
      } catch(__) {
          console.error(`Double erreur de chargement pour ${s}:${a}`, __);
      }
  }
  
  // Fallback si tout échoue complètement pour l'Arabe 
  if(!arabic){ 
    try{ 
      const j2=await fetchJSONWithFallback(API.sutanlab.surahAyah(s,a)); 
      arabic=j2?.data?.text?.arab||j2?.data?.text||""; 
    }catch(_){} 
  }

  const out={arabic:arabic||'(texte indisponible)',tr,audio,trEdition:trEd,reciter:reciterEd}; 
  return out; 
}

const els={ 
  main:byId('main'), controls: byId('controls'), btnBack: byId('btn-back'), brand: document.getElementById('brand-home'), 
  modeJuz: byId('mode-juz'), modeSurah: byId('mode-surah'), 
  fieldJuz: byId('field-juz'), fieldSurah: byId('field-surah'), 
  juzChecks: byId('juzChecks'), surahChecks: byId('surahChecks'), surahSearch: byId('surahSearch'), 
  translation: byId('translation'), reciter: byId('reciter'), 
  btnRand: byId('btn-random'), btnReroll: byId('btn-reroll'), btnNext: byId('btn-next'), 
  btnDiag: byId('btn-diagnose'), 
  btnCacheManager: byId('btn-cache-manager'), 
  status: byId('status'), meta: byId('meta'), ar: byId('ar'), tr: byId('tr'), chunk: byId('chunk'), 
  audio: byId('audio'), poolInfo: byId('poolInfo'), card: byId('card'), 
  juzAll: byId('juz-all'), surahAll: byId('surah-all'),
  // Éléments de la Modale
  modalCache: byId('modal-cache'), closeCacheModal: byId('close-cache-modal'),
  cacheReciters: byId('cacheReciters'), cacheTranslations: byId('cacheTranslations'),
  cacheSurahStart: byId('cacheSurahStart'), cacheSurahEnd: byId('cacheSurahEnd'),
  btnStartPreload: byId('btn-start-preload'),
  preloadProgressContainer: byId('preload-progress-container'),
  preloadStatusText: byId('preload-status-text'),
  preloadBar: byId('preload-bar')
};
let pool=[], shuffler=new SmartShuffle([],DEFAULT_RECENCY), currentKey=null, currentIndex=-1, isPreloading = false;
let revealMeta=false; 
let chunkBaseSurah=null, chunkStartAyah=null;

function setStatus(text,spin=false){ 
  if(!els.status) return; 
  els.status.innerHTML = spin ? `<span class=\"spinner\"></span> ${text}` : text; 
}
function setPreloadStatus(text, progress){
    els.preloadStatusText.textContent = text;
    els.preloadBar.style.width = `${progress}%`;
    els.preloadProgressContainer.classList.remove('hidden');
}
function renderPoolInfo(){ 
  const surahCount = new Set(pool.map(k=>+k.split(':')[0])).size; 
  els.poolInfo.textContent = `Pool: ${pool.length} versets · ${surahCount} sourate(s)`; 
}
function currentMode(){ return els.modeSurah.checked ? 'surah' : 'juz'; }
function showModeFields(){ 
  if(currentMode()==='surah'){ 
    els.fieldSurah.classList.remove('hidden'); els.fieldJuz.classList.add('hidden'); 
  } else { 
    els.fieldJuz.classList.remove('hidden'); els.fieldSurah.classList.add('hidden'); 
  } 
}
function collapseSelection(){ 
  els.controls.classList.add('hidden'); els.card.classList.remove('hidden'); 
  els.btnBack.classList.remove('hidden'); 
  els.main.classList.remove('selection'); els.main.classList.add('collapsed'); 
}
function expandSelection(){ 
  els.controls.classList.remove('hidden'); els.card.classList.add('hidden'); 
  els.btnBack.classList.add('hidden'); 
  els.main.classList.add('selection'); els.main.classList.remove('collapsed'); 
  window.scrollTo({top:0,behavior:'smooth'}); 
}

function buildCheckboxes(container, options, name, checkedFn){
    container.innerHTML = '';
    const frag = document.createDocumentFragment();
    options.forEach(opt => {
        const lab=document.createElement('label'); lab.className='chk'; 
        const cb=document.createElement('input'); cb.type='checkbox'; cb.value=opt.value; cb.name=name; 
        if (checkedFn && checkedFn(opt.value)) {
            cb.checked = true;
        }
        const span=document.createElement('span'); span.textContent=opt.label; 
        lab.appendChild(cb); lab.appendChild(span); frag.appendChild(lab);
    });
    container.appendChild(frag);
}


async function init(){
  els.brand?.addEventListener('click', ()=>{ expandSelection(); });

  const jfrag=document.createDocumentFragment();
  for(let j=1;j<=30;j++){
    const lab=document.createElement('label'); lab.className='chk';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.value=String(j); cb.name='juz';
    const span=document.createElement('span'); span.textContent=`Juz ${j}`;
    lab.appendChild(cb); lab.appendChild(span); jfrag.appendChild(lab);
  }
  els.juzChecks.appendChild(jfrag);

  setStatus('Chargement des sourates…', true);
  await buildSurahChecks();
  showModeFields();

  // Initialisation des options de la modale de cache
  // On présélectionne le récitateur et la traduction par défauts (sinon tout est décoché)
  buildCheckboxes(els.cacheReciters, RECITER_OPTIONS, 'cache-reciter', (val) => val === els.reciter.value);
  buildCheckboxes(els.cacheTranslations, TRANSLATION_OPTIONS, 'cache-translation', (val) => val === els.translation.value);
  
  els.modeJuz.addEventListener('change', ()=>{ showModeFields(); pool=[]; currentKey=null; currentIndex=-1; renderPoolInfo(); setStatus('Mode Juz — coche 1+ Juz, puis tire un verset.'); expandSelection(); });
  els.modeSurah.addEventListener('change', ()=>{ showModeFields(); pool=[]; currentKey=null; currentIndex=-1; renderPoolInfo(); setStatus('Mode Sourate — coche 1+ sourates, puis tire un verset.'); expandSelection(); });
  els.juzChecks.addEventListener('change', async ()=>{ if(currentMode()==='juz'){ await buildPool(); }});
  els.surahChecks.addEventListener('change', async ()=>{ if(currentMode()==='surah'){ await buildPool(); }});
  els.translation.addEventListener('change', async ()=>{ if(currentKey){ await refreshDisplay(); }});
  els.reciter.addEventListener('change', async ()=>{ if(currentKey){ await refreshDisplay(); }});
  els.surahSearch.addEventListener('input', (e)=>filterSurahChecks(e.target.value));
  els.juzAll?.addEventListener('click', ()=>setAllChecks('juzChecks',true));
  els.surahAll?.addEventListener('click', ()=>setAllChecks('surahChecks',true));

  // Boutons Tirer
  els.btnRand.addEventListener('click', async (e)=>{ e.preventDefault(); await ensurePool(); if(!pool.length){ setStatus('Pool vide: coche au moins un Juz ou une Sourate.'); return; } const key=shuffler.next(SMART); suppressCardClickUntil=Date.now()+500; await showSingleFromKey(key, true); });
  els.btnReroll.addEventListener('click', async ()=>{ await ensurePool(); if(!pool.length){ setStatus('Pool vide: coche au moins un Juz ou une Sourate.'); expandSelection(); return; } const key=shuffler.next(SMART); suppressCardClickUntil=Date.now()+400; await showSingleFromKey(key, false); });

  // Navigation
  els.btnNext.addEventListener('click', async (e)=>{ e.stopPropagation(); if(revealMeta){ await chunkNext(); } else { await revealAndShowChunk(); } });
  els.btnDiag.addEventListener('click', diagnose);
  els.btnBack.addEventListener('click', ()=>{ expandSelection(); });

  // Gestion de la Modale : Afficher la modale au clic du bouton
  els.btnCacheManager.addEventListener('click', ()=>{ 
      console.log('--- Cache Manager Button Clicked ---'); // Log de confirmation
      // Synchroniser les valeurs de la modale avec les valeurs par défaut actuelles
      const currentReciter = els.reciter.value;
      const currentTr = els.translation.value;
      Array.from(els.cacheReciters.querySelectorAll('input')).forEach(cb => {
          cb.checked = (cb.value === currentReciter);
      });
      Array.from(els.cacheTranslations.querySelectorAll('input')).forEach(cb => {
          cb.checked = (cb.value === currentTr);
      });
      
      els.modalCache.classList.remove('hidden');
      els.preloadProgressContainer.classList.add('hidden'); // Cacher la progression au nouvel affichage
  });
  // Fermer la modale
  els.closeCacheModal.addEventListener('click', ()=>{ els.modalCache.classList.add('hidden'); });
  els.modalCache.addEventListener('click', (e)=>{ if(e.target === els.modalCache) els.modalCache.classList.add('hidden'); });
  els.btnStartPreload.addEventListener('click', preloadSelectedAyahs);


  els.card.addEventListener('click', async (evt)=>{ if(Date.now()<suppressCardClickUntil) return; if(!currentKey) return; if(evt.target.closest('button, audio')) return; if(revealMeta){ await chunkNext(); } else { await revealAndShowChunk(); } });
  window.addEventListener('keydown', async (e)=>{
    if(e.code==='Space' || e.key===' '){ e.preventDefault(); const au=els.audio; if(au && au.src){ if(au.paused){ try{ await au.play(); }catch(_){ } } else { au.pause(); } } return; }
    if(e.key==='ArrowRight'){ e.preventDefault(); if(!currentKey) return; if(revealMeta){ await chunkNext(); } else { await revealAndShowChunk(); } }
    if(e.key==='Enter'){ e.preventDefault(); els.btnReroll.click(); }
  });

  await buildPool(); setStatus('Prêt.');
}

async function ensurePool(){ if(!pool.length) await buildPool(); }

async function buildPool(){
  if(currentMode()==='juz'){
    const js = selectedFromChecks('juzChecks').map(Number).filter(Boolean);
    if(!js.length){ setStatus('Coche au moins un Juz.'); pool=[]; renderPoolInfo(); return; }
    setStatus('Chargement des Juz…', true);
    let acc=[]; for(const j of js){ try{ const list=await loadJuz(j); acc=acc.concat(list.map(x=>ayahKey(x.s,x.a))); }catch(e){ setStatus('APIs Juz indisponibles pour certains éléments.'); } }
    pool = uniq(acc);
  } else {
    const ss = selectedFromChecks('surahChecks').map(Number).filter(Boolean);
    if(!ss.length){ setStatus('Coche au moins une sourate.'); pool=[]; renderPoolInfo(); return; }
    let acc=[]; 
    for(const s of ss){ 
      const meta=(Cache.surahIndex||[]).find(x=>+x.n===s); 
      const count=meta?.count||200; 
      
      // La logique d'itération jusqu'à 'count' est conservée.
      for(let a=1;a<=count;a++){ 
        acc.push(ayahKey(s,a)); 
      } 
    } 
    pool = acc;
  }
  shuffler.set(pool); shuffler.setHistorySize(DEFAULT_RECENCY);
  currentKey=null; currentIndex=-1; revealMeta=false; chunkBaseSurah=null; chunkStartAyah=null; clearChunk();
  renderPoolInfo();
  setStatus(`${currentMode()==='juz'?'Juz':'Sourate(s)'} prêtes.`);
}

async function showSingleFromKey(key, collapse=false){
  currentKey = key; currentIndex = pool.indexOf(key);
  const [s,a] = key.split(':').map(Number);
  revealMeta = false; chunkBaseSurah = s; chunkStartAyah = a+1;
  if(collapse) collapseSelection();
  await displaySingle(s,a,false);
}

async function revealAndShowChunk(){ if(!currentKey) return; const [s,a]=currentKey.split(':').map(Number); revealMeta=true; chunkBaseSurah = s; chunkStartAyah = a+1; await displayChunk(s, chunkStartAyah, CHUNK_SIZE, true); }
async function refreshDisplay(){ 
  if(!currentKey) return;
  const [s,a]=currentKey.split(':').map(Number); 
  if(revealMeta){ 
    await displayChunk(chunkBaseSurah, chunkStartAyah, CHUNK_SIZE, true); 
  } else { 
    await displaySingle(s,a,false); 
  } 
}
function clearChunk(){ els.chunk.innerHTML=''; }

async function displaySingle(s,a,showMeta){
  clearChunk(); els.meta.classList.toggle('hidden', !showMeta);
  const meta=(Cache.surahIndex||[]).find(x=>+x.n===s); const title = meta ? `${pretty(s)} · ${meta.label}` : `Sourate ${s}`;
  els.meta.textContent = `${title} — Verset ${a}`;
  els.ar.textContent='Chargement…'; els.tr.textContent=''; els.audio.classList.add('hidden'); els.audio.src='';
  try{ const data=await getAyah(s,a,els.translation.value,els.reciter.value); els.ar.textContent=data.arabic||'(indisponible)'; els.tr.textContent=data.tr||''; if(data.audio){ els.audio.src=data.audio; els.audio.classList.remove('hidden'); } }
  catch(e){ els.ar.textContent='(erreur de chargement)'; setStatus('Impossible de charger ce verset.'); }
}

async function displayChunk(s,start,count,showMeta){
  els.meta.classList.toggle('hidden', !showMeta);
  const meta=(Cache.surahIndex||[]).find(x=>+x.n===s); const title = meta ? `${pretty(s)} · ${meta.label}` : `Sourate ${s}`;
  els.meta.textContent = `${title}`;
  els.ar.textContent=''; els.tr.textContent=''; clearChunk();
  
  const last = meta?.count || 200; // Utilise le nombre de versets réel
  const end = Math.min(last, start + count - 1);
  
  if(start > last){ 
    els.chunk.innerHTML='<div class="muted">Fin de la sourate.</div>'; 
    return; 
  }
  
  for(let a=start; a<=end; a++){
    try{
      const data=await getAyah(s,a,els.translation.value,els.reciter.value);
      const div=document.createElement('div'); div.className='chunk-item';
      const num=document.createElement('div'); num.className='num'; num.textContent=`${title} — ${a}`;
      const ar=document.createElement('div'); ar.className='arabic'; ar.textContent=data.arabic||'(indisponible)';
      const tr=document.createElement('div'); tr.className='trans'; tr.textContent=data.tr||'';
      div.appendChild(num); div.appendChild(ar); if(tr.textContent) div.appendChild(tr);
      els.chunk.appendChild(div);
      if(a===start){ 
        if(data.audio){ 
          els.audio.src=data.audio; 
          els.audio.classList.remove('hidden'); 
        } else { 
          els.audio.src=''; 
          els.audio.classList.add('hidden'); 
        } 
      }
    }catch(_){ setStatus('Erreur de chargement sur un verset.'); }
  }
}

async function chunkNext(){ 
  if(!revealMeta) return; 
  const s=chunkBaseSurah; 
  const meta=(Cache.surahIndex||[]).find(x=>+x.n===s); 
  const last=meta?.count||200; 
  const nextStart=(chunkStartAyah||1)+CHUNK_SIZE; 
  
  if(nextStart > last){ 
    setStatus('Fin de la sourate. Tirage d\'un nouveau verset aléatoire...', true); 
    // Passe au verset aléatoire suivant après la fin de la sourate.
    const key = shuffler.next(SMART);
    suppressCardClickUntil = Date.now() + 400;
    await showSingleFromKey(key, false);
    setStatus('Nouveau verset tiré.');
    return; 
  } 
  chunkStartAyah=nextStart; 
  await displayChunk(s, chunkStartAyah, CHUNK_SIZE, true); 
}

/**
 * Prépare et lance le téléchargement séquentiel de tous les versets sélectionnés.
 */
async function preloadSelectedAyahs(){
  console.log('preloadSelectedAyahs: Démarrage de la fonction de pré-chargement sélectif.');
  if(isPreloading) return; 
  
  const reciterEditions = selectedFromChecks('cacheReciters');
  const translationEditions = selectedFromChecks('cacheTranslations').filter(ed => ed !== 'none'); // Exclut 'none'
  const surahStart = Math.max(1, Math.min(114, Number(els.cacheSurahStart.value) || 1));
  const surahEnd = Math.max(1, Math.min(114, Number(els.cacheSurahEnd.value) || 114));
  
  if (reciterEditions.length === 0 && translationEditions.length === 0) {
      setPreloadStatus('Erreur : Veuillez sélectionner au moins un récitateur ou une traduction à mettre en cache.', 0);
      return;
  }
  if (surahStart > surahEnd) {
      setPreloadStatus('Erreur : La sourate de début doit être inférieure ou égale à la sourate de fin.', 0);
      return;
  }
  
  isPreloading = true;
  els.btnStartPreload.disabled = true;
  setPreloadStatus('Vérification de la liste des sourates...', 0);

  await loadSurahList(); 
  const surahs = Cache.surahIndex.filter(s => s.n >= surahStart && s.n <= surahEnd);
  
  if(!surahs || surahs.length === 0) {
      isPreloading = false;
      els.btnStartPreload.disabled = false;
      setPreloadStatus('Erreur: Aucune sourate trouvée dans la plage sélectionnée.', 0);
      return;
  }
  
  // Compte le nombre total d'opérations de mise en cache (nombre de versets * nombre d'éditions distinctes)
  // L'arabe (quran-uthmani) et l'audio sont mis en cache ensemble pour chaque récitateur.
  // L'arabe et toutes les traductions sont mis en cache ensemble dans une requête par verset.
  let totalVersesToCache = 0;
  
  // Calcul basé sur les requêtes réelles :
  // Chaque récitateur sélectionné = 1 requête par verset (Audio + Arabe)
  totalVersesToCache += surahs.reduce((sum, s) => sum + s.count, 0) * reciterEditions.length;
  
  // Si des traductions sont sélectionnées = 1 requête par verset (Arabe + Traductions)
  if (translationEditions.length > 0) {
      totalVersesToCache += surahs.reduce((sum, s) => sum + s.count, 0);
  }

  let versesCached = 0; // Compte le nombre de requêtes de cache réussies
  
  setPreloadStatus(`Début du téléchargement (0/${totalVersesToCache} requêtes)...`, 0);

  const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
  const arabicEdition = 'quran-uthmani';

  for (const surah of surahs) {
    const s = surah.n;
    const limit = surah.count; 

    for (let a = 1; a <= limit; a++) {
      
      // 1. Mise en cache de l'Audio et de l'Arabe (pour chaque récitateur sélectionné)
      for (const reciterEd of reciterEditions) {
          let editions = [arabicEdition, reciterEd];
          const url = `https://api.alquran.cloud/v1/ayah/${s}:${a}/${editions.join(',')}`;
          
          try {
            // Utilisation de fetch avec 'force-cache' pour s'assurer que le SW intercepte et met en cache.
            const response = await fetch(url, { cache: 'force-cache' }); 
            if (response.ok) { versesCached++; } else { console.warn(`[Preload] Échec cache Audio/Arabe ${reciterEd} pour ${s}:${a}. Status: ${response.status}`); }
          } catch (error) {
            console.error(`[Preload] Erreur de fetch Audio/Arabe ${reciterEd} pour ${s}:${a}:`, error);
          }
          await delay(50); // Petit délai pour l'API
      }
      
      // 2. Mise en cache des Traductions (une seule requête pour toutes les traductions sélectionnées + Arabe)
      if (translationEditions.length > 0) {
          let editions = [arabicEdition, ...translationEditions];
          const url = `https://api.alquran.cloud/v1/ayah/${s}:${a}/${editions.join(',')}`;

          try {
            const response = await fetch(url, { cache: 'force-cache' }); 
            if (response.ok) { versesCached++; } else { console.warn(`[Preload] Échec cache Traductions pour ${s}:${a}. Status: ${response.status}`); }
          } catch (error) {
            console.error(`[Preload] Erreur de fetch Traductions pour ${s}:${a}:`, error);
          }
          await delay(50); // Petit délai pour l'API
      }
      

      // Affichage de la progression
      if(totalVersesToCache > 0 && (versesCached % 50 === 0 || versesCached === totalVersesToCache)){
          const progress = (versesCached / totalVersesToCache) * 100;
          setPreloadStatus(`Téléchargement: ${versesCached}/${totalVersesToCache} requêtes (${progress.toFixed(1)}%)…`, progress);
      }
    }
  }

  isPreloading = false;
  els.btnStartPreload.disabled = false;
  // Fermer la modale après le téléchargement
  els.modalCache.classList.add('hidden'); 
  setStatus(`Terminé! ${versesCached} requêtes de données sont maintenant disponibles hors-ligne pour la sélection choisie.`, false);
}


async function diagnose(){ 
  const tests=[ 
    ['Sutanlab surahList',API.sutanlab.surahList], 
    ['AlQuran surahList',API.alquran.surahList] 
  ]; 
  let ok=0,msgs=[]; 
  for(const [name,url] of tests){ 
    try{ 
      // Utilisation du fallback pour le diagnostic aussi
      const j=await fetchJSONWithFallback(url); 
      if(j){ ok++; msgs.push(`${name}: OK`);} 
      else { msgs.push(`${name}: vide`); } 
    }catch(e){ msgs.push(`${name}: KO`); } 
  } 
  if(els.status) els.status.textContent=`Diagnostic — ${ok}/${tests.length} OK. ${msgs.join(' · ')}`; 
}

// --- AJOUT PWA ---
// Enregistrement du Service Worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js') 
      .then(reg => console.log('Service Worker enregistré.', reg))
      .catch(err => console.log('Échec de l\'enregistrement du Service Worker:', err));
  });
}
// --- FIN AJOUT PWA ---

init();
</script>
</body>
</html>
